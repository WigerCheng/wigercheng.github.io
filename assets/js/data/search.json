[ { "title": "Android动画之淡入淡出动画", "url": "/posts/Android_Fade_Animation/", "categories": "Android, Animation", "tags": "Animation", "date": "2022-04-25 00:00:00 +0800", "snippet": "淡入淡出动画在安卓开发中，常用淡入淡出的动画来显示加载中的效果。比如在加载新闻列表时，先显示骨架屏动画，当请求成功后，骨架屏以淡出的形式消失，新闻列表项以淡入的形式出现。或者是加载图片的时候，默认显示一个空的图片或占位图片，当图片加载成功，占位图片以淡出的形式消失，加载的图片以淡入的形式显示。一个简单的例子。以Android Logo作为占位图，员工头像为请求的图片。实现淡入淡出动画 准备两个ImageView一个ImageView显示占位图，一个显示ImageView请求的图片。请求图片的ImageView的visibility默认是Gone。&amp;lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/v_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/profile_picture&quot; android:visibility=&quot;gone&quot; /&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/v_loading&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&amp;gt;&amp;lt;/FrameLayout&amp;gt; 执行动画把加载图片的ImageView的visibility设为VISIBLE，并执行从透明到不透明的动画，实现淡入效果。占位图的ImageView执行不透明到透明的动画，实现淡出效果，监听动画回调，当动画执行结束后，将占位图的visibility设为GONE。//动画时长val shortAnimationDuration = resources.getInteger(android.R.integer.config_longAnimTime).toLong()private fun crossFade() { content.run { //淡入的View从初始状态的GONE切换成Visible，然后通过透明度0隐藏。 visibility = View.VISIBLE alpha = 0F //执行动画 animate() .alpha(1F) .setDuration(shortAnimationDuration) } loading.animate() .alpha(0F) .setDuration(shortAnimationDuration) .setListener(object : AnimatorListenerAdapter() { override fun onAnimationEnd(animation: Animator?) { super.onAnimationEnd(animation) loading.visibility = View.GONE } })}代码参考代码" }, { "title": "Android动画之圆形揭露动画", "url": "/posts/Android_Circle_Animation/", "categories": "Android, Animation", "tags": "Animation", "date": "2022-04-24 00:00:00 +0800", "snippet": "圆形揭露动画圆形揭露动画，可以让一个View裁剪成一个圆形，并以指定的圆心做半径变化动画。当您显示或隐藏一组界面元素时，可给用户提供视觉连续性。使用圆形揭露动画通过调用ViewAnimationUtils.createCircularReveal()返回一个Animator实例，调用animator.start()显示动画。createCircularReveal() 动画采用五个参数。 View -&amp;gt; 即要执行动画的View。 centerX -&amp;gt; 指定圆心的x点坐标。 centerY -&amp;gt; 指定圆心的y点坐标。 startRadius -&amp;gt; 动画开始前剪裁圆形的半径 。 endRadius -&amp;gt; 动画结束时的圆形半径。代码实现参考findViewById&amp;lt;Button&amp;gt;(R.id.btn_circle_scale_down).setOnClickListener { val image = findViewById&amp;lt;ImageView&amp;gt;(R.id.img_circle) val width = image.width val height = image.height image.visibility = View.VISIBLE ViewAnimationUtils.createCircularReveal( image, width / 2, height / 2, 0F, width.toFloat() ).apply { duration = 2000L }.also { it.start() } }" }, { "title": "Android开发——颜色", "url": "/posts/Android_Color/", "categories": "Android, Develop", "tags": "Theme", "date": "2022-04-20 00:00:00 +0800", "snippet": " Android中的颜色值通常遵循RGB/ARGB标准，使用时通常以“ # ”字符开头的8位16进制表示。其中ARGB 依次代表透明度（Alpha）、红色(Red)、绿色(Green)、蓝色(Blue)，取值范围为0 ~ 255（即16进制的0x00 ~ 0xff）。 作者：翻译不了的声响链接：https://www.jianshu.com/p/3c1fe10aed4f来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。透明度参考表 透明度 取值 100% 00 95% 0D 90% 1A 85% 26 80% 33 75% 40 70% 4D 65% 59 60% 66 55% 73 50% 80 45% 8C 40% 99 35% A6 30% B3 25% BF 20% CC 15% D9 10% E6 5% F2 0% FF " }, { "title": "Android MVP架构", "url": "/posts/Android_MVP/", "categories": "Android, Architecture", "tags": "Develop", "date": "2022-04-19 00:00:00 +0800", "snippet": "什么是MVP？MVP的全称为Model-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。来自维基百科的模型描述 Model-View-Presenter (MVP) 是用户界面设计模式的一种，被广泛用于便捷自动化单元测试和在呈现逻辑中改良分离关注点（separation of concerns）。 Model 定义用户界面所需要被显示的资料模型，一个模型包含着相关的业务逻辑。 View 视图为呈现用户界面的终端，用以表现来自 Model 的资料，和用户命令路由再经过 Presenter 对事件处理后的资料。 Presenter 包含着组件的事件处理，负责检索 Model 获取资料，和将获取的资料经过格式转换与 View 进行沟通。 Android 实现代码参考谷歌官方的Demo。To-DoApp的todo-mvp-kotlin分支1. 定义BaseView和BasePresenter 其中BaseView持有一个presenter成员。实现BasePresenter要实现start()方法。interface BaseView&amp;lt;T&amp;gt; { var presenter: T}interface BasePresenter { fun start()}2.明确功能需求，编写功能级的View和Presenter以Task详情页为例，用户能执行4种操作，分别是编辑Task、删除Task、改变Task完成状态（已完成、未完成）。根据上面的需求，我们Task详情页的Presenter代码如下。interface Presenter : BasePresenter { // 编辑Task fun editTask() // 删除Task fun deleteTask() // 完成Task fun completeTask() // 激活Task fun activateTask()}interface View : BaseView&amp;lt;Presenter&amp;gt; { val isActive: Boolean // 是否显示加载中 fun setLoadingIndicator(active: Boolean) // 显示找不到Task fun showMissingTask() // Task为空时，隐藏标题 fun hideTitle() // 显示并显示标题 fun showTitle(title: String) // Task为空时，隐藏描述 fun hideDescription() // 显示并显示描述 fun showDescription(description: String) // 显示Task的完成状态 fun showCompletionStatus(complete: Boolean) // 跳转编辑Task的Activity fun showEditTask(taskId: String) // 执行Task删除后的逻辑 fun showTaskDeleted() // 显示Task已完成的界面 fun showTaskMarkedComplete() // 显示Task已已激活的界面 fun showTaskMarkedActive()}3.业务代码分析 TaskDetailActivity是容器，具体实现逻辑在TaskDetailFragment。 在TaskDetailActivity里，将TaskDetailPresenter和TaskDetailFragment（已实现View接口） 绑定在一起，如何绑定见下文2。 override fun onCreate(savedInstanceState: Bundle?) { ... //取得TaskDetailFragment实例 val taskDetailFragment = ... TaskDetailPresenter(..., taskDetailFragment) ... } TaskDetailPresenter接收实现了View接口的UI，即TaskDetailFragment，并实现Presenter接口，在构造方法的时候通过调用 taskDetailView.presenter = this 绑定在一起。 class TaskDetailPresenter( ... private val taskDetailView: TaskDetailContract.View ) : TaskDetailContract.Presenter { init { taskDetailView.presenter = this } ... //实现TaskDetailContract.Presenter的方法 ... } TaskDetailFragment实现View接口，并持有presenter实例和Presenter进行交互。在onResume的时候，调用Presenter的start()方法启动Presenter，开始交互。 class TaskDetailFragment : Fragment(), TaskDetailContract.View { override lateinit var presenter: TaskDetailContract.Presenter override fun onResume() { super.onResume() presenter.start() } ... //实现TaskDetailContract.View的方法和属性 ... } TaskDetailFragment调用TaskDetailPresenter的方法执行业务逻辑，TaskDetailPresenter调用TaskDetailContract.View的方法，让TaskDetailFragment更新页面UI。 调用presenter.deleteTask()删除Task override fun onOptionsItemSelected(item: MenuItem): Boolean { val deletePressed = item.itemId == R.id.menu_delete if (deletePressed) presenter.deleteTask() return deletePressed } presenter根据实际情况调用View的方法更新UI。如果taskId为空，则调用showMissingTask()显示没有Task，否则执行删除逻辑并调用showTaskDeleted()显示删除成功。 override fun deleteTask() { if (taskId.isEmpty()) { taskDetailView.showMissingTask() return } tasksRepository.deleteTask(taskId) taskDetailView.showTaskDeleted() } TaskDetailFragment执行最终显示UI的方法。 override fun showMissingTask() { detailTitle.text = &quot;&quot; detailDescription.text = getString(R.string.no_data) } override fun showTaskDeleted() { activity?.finish() } " }, { "title": "Android动画之视图动画", "url": "/posts/Android_Basic_Animation/", "categories": "Android, Animation", "tags": "Animation", "date": "2022-04-19 00:00:00 +0800", "snippet": "Android View 动画框架 Animation框架定义了透明度、旋转、缩放和位移几种常见的动面，而且控制的是整个view，实现原理是每次绘制视图时 View 所在的 ViewGroup 中的drawChild 函数获取该 View 的Animation 的 Transformation 值，然后调用 canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧。如果动画没有完成，就继续调用 invalidate()函数，启动下次绘制來驱动动画，从而完成整个动画的绘制。——《Android群英传》视图动画四种动画方式AlphaAnimation（透明度动画） 为视图添加透明度的变换动画。 构建AlphaAnimation2个参数 fromAlpha 开始的透明度 toAlpha 结束的透明度 //透明度从0到1，时长1秒private fun alphaAnimation(v: View) { with(AlphaAnimation(0F, 1F)) { duration = 1000 v.startAnimation(this) }}RotateAnimation（旋转动画） 为视图增加旋转的变换动画。 构建RotateAnimation6个参数 fromDegrees 旋转开始的角度 toDegrees 旋转结束的角度 pivotXType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT X值取值是View的绝对值，还是以View或View双亲的宽高百分比。 pivotXValue（默认为0） X的取值（如果pivotXType不是ABSOLUTE，则取值范围是0F~1F即百分比） pivotYType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT Y值取值是View的绝对值，还是以View或View双亲的宽高百分比。 pivotYValue（默认为0）Y的取值（如果pivotYValue不是ABSOLUTE，则取值范围是0F~1F即百分比） //以View的（0，0）点为中心（即左上角），从0度旋转到360度，时长1秒。private fun rotateAnimation(v: View) { with(RotateAnimation(0F, 360F, 0F, 0F)) { duration = 1000 v.startAnimation(this) }}//以View的宽高一半的点为中心（即View正中心），从0度旋转到360度，时长1秒。private fun rotateSelfAnimation(v: View) { with( RotateAnimation( 0F, 360F, RotateAnimation.RELATIVE_TO_SELF, 0.5F, RotateAnimation.RELATIVE_TO_SELF, 0.5F ) ) { duration = 1000 v.startAnimation(this) }}TranslateAnimation（位移动画） 为视图移动时增加位移动画。 构建TranslateAnimation的8个参数 fromXType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 移动前X的取值是View的绝对值，还是以View或View双亲的宽高百分比 fromXValue 移动前的X位置（如果fromXType不是ABSOLUTE，则取值范围是0F~1F即百分比） toXType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 移动后X的取值是View的绝对值，还是以View或View双亲的宽高百分比 toXValue 移动后的X位置（如果toXType不是ABSOLUTE，则取值范围是0F~1F即百分比） fromYType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 移动前Y的取值是View的绝对值，还是以View或View双亲的宽高百分比。 fromYValue 移动前的Y位置（如果fromYType不是ABSOLUTE，则取值范围是0F~1F即百分比） toYType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT 移动后Y的取值是View的绝对值，还是以View或View双亲的宽高百分比。 toYValue 移动后的Y位置（如果toYType不是ABSOLUTE，则取值范围是0F~1F即百分比） //以View（0，0）点即左上角移到（200，300）的位置，时长1秒private fun translateAnimation(v: View) { with(TranslateAnimation(0F, 200F, 0F, 300F)) { duration = 1000 v.startAnimation(this) }}ScaleAnimation（缩放动画） 为视图的缩放增加动画效果。 构建ScaleAnimation的8个参数 fromX 水平方向初始缩放比例 toX 水平方向结束缩放比例 fromY 垂直方向初始缩放比例 toY 垂直方向结束缩放比例 pivotXType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT X值取值是View的绝对值，还是以View或View双亲的宽高百分比。 pivotXValue（默认为0） 动画缩放初始点的X值（如果pivotXType不是ABSOLUTE，则取值范围是0F~1F即百分比） pivotYType ABSOLUTE（默认值）、Animation.RELATIVE_TO_SELF、Animation.RELATIVE_TO_PARENT Y值取值是View的绝对值，还是以View或View双亲的宽高百分比。 pivotYValue（默认为0） 动画缩放初始点的Y值（如果pivotYValue不是ABSOLUTE，则取值范围是0F~1F即百分比） //以View（0，0）点即左上角从宽高为0缩放到原宽高的2倍，时长1秒private fun scaleAnimation(v: View) { with(ScaleAnimation(0F, 2F, 0F, 2F)) { duration = 1000 v.startAnimation(this) }}//以View的宽高一半的点为中心（即View正中心）从宽高为0缩放到原宽高的1倍，时长1秒private fun scaleSelfAnimation(v: View) { with( ScaleAnimation( 0F, 1F, 0F, 1F, Animation.RELATIVE_TO_SELF, 0.5F, Animation.RELATIVE_TO_SELF, 0.5F ) ) { duration = 1000 v.startAnimation(this) }}AnimationSet（动画集合） 通过AnimationSet可以将动画以组合的形式展现出来 构造AnimationSet的1个参数 shareInterpolator 是否集合内的动画和AnimationSet公用一个插值器，否则每个动画各用回自己的插值器。 private fun animationSet(v: View) { val animationSet = AnimationSet(true).apply { duration = 1000 } val alpha = AlphaAnimation(0F, 1F).apply { duration = 1000 } animationSet.addAnimation(alpha) val translate = TranslateAnimation(0F, 100F, 0F, 200F).apply { duration = 1000 } animationSet.addAnimation(translate) v.startAnimation(animationSet)}代码代码参考" }, { "title": "Android序列化之Parcelable", "url": "/posts/Parcelable/", "categories": "Android, Serializable", "tags": "Develop", "date": "2022-03-16 00:00:00 +0800", "snippet": "1、什么是Parcel Container for a message (data and object references) that can be sent through an IBinder. A Parcel can contain both flattened data that will be unflattened on the other side of the IPC (using the various methods here for writing specific types, or the general Parcelable interface), and references to live IBinder objects that will result in the other side receiving a proxy IBinder connected with the original IBinder in the Parcel. Parcel 一个在IBinder中传输的消息容器。 进程间通信，发送端打包数据，接收端解包数据，实现数据传输。 Parcel 不是通用序列化机制，您绝不能将任何 Parcel 数据存储在磁盘上或通过网络发送。2、Parcel支持的类型 Byte, ByteArray Double, DoubleArray Float, FloatArray Int, IntArray Long, LongArray String, StringArray …3、实现Parcelable(手动实现Parcelable接口)import android.os.Parcelimport android.os.Parcelabledata class Pet( val name: String) : Parcelable { constructor(parcel: Parcel) : this(parcel.readString() ?: &quot;pet&quot;) override fun writeToParcel(parcel: Parcel, flags: Int) { parcel.writeString(name) } override fun describeContents(): Int { return 0 } companion object CREATOR : Parcelable.Creator&amp;lt;Pet&amp;gt; { override fun createFromParcel(parcel: Parcel): Pet { return Pet(parcel) } override fun newArray(size: Int): Array&amp;lt;Pet?&amp;gt; { return arrayOfNulls(size) } }}data class Person( val id: Long, var name: String, var age: Int, var isStudent: Boolean, var pets: List&amp;lt;Pet&amp;gt;) : Parcelable { constructor(parcel: Parcel) : this( parcel.readLong(), parcel.readString() ?: &quot;&quot;, parcel.readInt(), parcel.readByte() != 0.toByte(), parcel.createTypedArrayList(Pet) ?: emptyList() ) override fun writeToParcel(parcel: Parcel, flags: Int) { parcel.writeLong(id) parcel.writeString(name) parcel.writeInt(age) parcel.writeByte(if (isStudent) 1 else 0) parcel.writeTypedList(pets) } override fun describeContents(): Int { return 0 } companion object CREATOR : Parcelable.Creator&amp;lt;Person&amp;gt; { override fun createFromParcel(parcel: Parcel): Person { return Person(parcel) } override fun newArray(size: Int): Array&amp;lt;Person?&amp;gt; { return arrayOfNulls(size) } }}4、实现Parcelable（通过 Parcelable 实现生成器 实现）Parcelable 实现生成器 添加 kotlin-parcelize 插件。 plugins { id &#39;kotlin-parcelize&#39;} apply plugin: &quot;kotlin-parcelize&quot; 编写数据类 @Parcelizedata class Person( val id: Long, var name: String, var age: Int, var isStudent: Boolean, var pets: List&amp;lt;Pet&amp;gt;) : Parcelable @Parcelize 支持的类型 基元类型（及其 boxed 版本） 对象和枚举 String、CharSequence Exception Size、SizeF、Bundle、IBinder、IInterface、FileDescriptor SparseArray、SparseIntArray、SparseLongArray、SparseBooleanArray 所有 Serializable（包括 Date）和 Parcelable 实现 所有受支持类型的集合： List（映射到 ArrayList）、Set（映射到 LinkedHashSet）、Map（映射到 LinkedHashMap） 此外，还有一些具体实现：ArrayList、LinkedList、SortedSet、NavigableSet、HashSet、LinkedHashSet、TreeSet、SortedMap、NavigableMap、HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap 所有受支持类型的数组 所有受支持类型的可为 null 版本 自定义Parcelerdata class Phone( val model: String)object PhoneClassParceler : Parceler&amp;lt;Phone&amp;gt; { override fun create(parcel: Parcel): Phone { return Phone(parcel.readString() ?: &quot;iPhone&quot;) } override fun Phone.write(parcel: Parcel, flags: Int) { parcel.writeString(model) }}@Parcelize@TypeParceler&amp;lt;Phone, PhoneClassParceler&amp;gt;()data class PhoneOwner(val phone: Phone) : Parcelable@Parcelizedata class PhoneOwner1(@TypeParceler&amp;lt;Phone, PhoneClassParceler&amp;gt;() val phone: Phone) : Parcelable@Parcelizedata class PhoneOwner2(val phone: @WriteWith&amp;lt;PhoneClassParceler&amp;gt;() Phone) : Parcelable" }, { "title": "Android动画之帧动画", "url": "/posts/Android_Frame_Animation/", "categories": "Android, Animation", "tags": "Animation", "date": "2022-03-15 00:00:00 +0800", "snippet": "帧动画是什么首先动画本质就是连成连贯动作的一帧帧静态图快速切换的效果。帧：就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图象等。在Android实现帧动画1、准备素材将图片资源放在drawable文件夹。如图所示👇2、编写动画资源文件在drawable文件夹下新建frame_anim.xml文件。文件内容如下&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation1&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation2&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation3&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation4&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation5&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation6&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation7&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation8&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation9&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation10&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation11&quot; android:duration=&quot;200&quot; /&amp;gt; &amp;lt;item android:drawable=&quot;@drawable/animation12&quot; android:duration=&quot;200&quot; /&amp;gt;&amp;lt;/animation-list&amp;gt;3、添加显示帧动画的ImageView&amp;lt;ImageView android:id=&quot;@+id/img_frame&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:src=&quot;@mipmap/ic_launcher&quot; /&amp;gt;4、编写实现帧动画的代码findViewById&amp;lt;ImageView&amp;gt;(R.id.img_frame).apply { setBackgroundResource(R.drawable.frame_anim) frameAnimation = background as AnimationDrawable tvOneShot.text = &quot;OneShot:${frameAnimation.isOneShot}&quot;}//开始动画findViewById&amp;lt;Button&amp;gt;(R.id.btn_start).setOnClickListener { frameAnimation.start()}5、效果 no_one_shot one_shot 6、代码代码参考" } ]
